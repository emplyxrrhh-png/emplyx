@using System.Linq.Expressions
@typeparam TValue

<div class="app-field">
    @if (!string.IsNullOrWhiteSpace(Label))
    {
        <label class="form-label">@Label</label>
    }

    @switch (NormalizedInputType)
    {
        case "textarea":
            <InputTextArea class="form-control"
                           placeholder="@Placeholder"
                           @bind-Value="StringValue"
                           @bind-Value:event="oninput" />
            break;
        case "select":
            <InputSelect TValue="TValue" class="form-select" @bind-Value="BoundValue">
                @if (!string.IsNullOrEmpty(Placeholder))
                {
                    <option value="">@Placeholder</option>
                }
                @ChildContent
            </InputSelect>
            break;
        case "number":
            <InputNumber TValue="TValue" class="form-control" @bind-Value="BoundValue" />
            break;
        default:
            <InputText class="form-control"
                       type="@InputType"
                       placeholder="@Placeholder"
                       @bind-Value="StringValue"
                       @bind-Value:event="oninput" />
            break;
    }

    @if (For is not null)
    {
        <ValidationMessage For="For" />
    }
</div>

@code {
    [Parameter] public string? Label { get; set; }
    [Parameter] public string? Placeholder { get; set; }
    [Parameter] public string InputType { get; set; } = "text";
    [Parameter] public TValue? Value { get; set; }
    [Parameter] public EventCallback<TValue?> ValueChanged { get; set; }
    [Parameter] public Expression<Func<TValue?>>? For { get; set; }
    [Parameter] public RenderFragment? ChildContent { get; set; }

    private TValue? _currentValue;

    private string NormalizedInputType => InputType?.ToLowerInvariant() ?? "text";

    protected override void OnParametersSet()
    {
        if (!EqualityComparer<TValue?>.Default.Equals(Value, _currentValue))
        {
            _currentValue = Value;
        }
    }

    private TValue? BoundValue
    {
        get => _currentValue;
        set
        {
            if (!EqualityComparer<TValue?>.Default.Equals(_currentValue, value))
            {
                UpdateCurrentValue(value);
            }
        }
    }

    private string? StringValue
    {
        get
        {
            EnsureStringField();
            return (string?)(object?)_currentValue;
        }
        set
        {
            EnsureStringField();
            UpdateCurrentValue((TValue?)(object?)value);
        }
    }

    private void UpdateCurrentValue(TValue? value)
    {
        _currentValue = value;
        _ = ValueChanged.InvokeAsync(value);
    }

    private static void EnsureStringField()
    {
        if (typeof(TValue) != typeof(string))
        {
            throw new InvalidOperationException("AppField text inputs require TValue=string. Set InputType=\"number\" or use a select control for other types.");
        }
    }
}
