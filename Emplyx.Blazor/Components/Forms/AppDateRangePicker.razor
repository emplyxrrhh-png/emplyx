@using System.Linq.Expressions

<div class="app-field app-date-range">
    @if (!string.IsNullOrWhiteSpace(Label))
    {
        <label class="form-label">@Label</label>
    }

    <div class="row gx-2 align-items-center">
        <div class="col">
            <InputDate TValue="DateTime?"
                       class="form-control"
                       aria-label="@FromAriaLabel"
                       min="@MinDateString"
                       max="@MaxDateString"
                       required="@IsRequired"
                       @bind-Value="BoundFrom" />
        </div>
        <div class="col-auto text-center fw-semibold">â€”</div>
        <div class="col">
            <InputDate TValue="DateTime?"
                       class="form-control"
                       aria-label="@ToAriaLabel"
                       min="@MinDateString"
                       max="@MaxDateString"
                       required="@IsRequired"
                       @bind-Value="BoundTo" />
        </div>
    </div>

    @if (!string.IsNullOrWhiteSpace(HelperText))
    {
        <small class="text-body-secondary">@HelperText</small>
    }

    @if (ForFrom is not null)
    {
        <ValidationMessage For="ForFrom" />
    }
    @if (ForTo is not null)
    {
        <ValidationMessage For="ForTo" />
    }
    @if (ForRange is not null)
    {
        <ValidationMessage For="ForRange" />
    }
</div>

@code {
    [Parameter] public string? Label { get; set; }
    [Parameter] public string? HelperText { get; set; }
    [Parameter] public string? FromAriaLabel { get; set; }
    [Parameter] public string? ToAriaLabel { get; set; }
    [Parameter] public DateTime? From { get; set; }
    [Parameter] public EventCallback<DateTime?> FromChanged { get; set; }
    [Parameter] public DateTime? To { get; set; }
    [Parameter] public EventCallback<DateTime?> ToChanged { get; set; }
    [Parameter] public EventCallback<DateRangeValue> RangeChanged { get; set; }
    [Parameter] public DateTime? Min { get; set; }
    [Parameter] public DateTime? Max { get; set; }
    [Parameter] public bool IsRequired { get; set; }
    [Parameter] public bool ValidateRange { get; set; } = true;
    [Parameter] public int MinimumSpanDays { get; set; } = 2;
    [Parameter] public Expression<Func<DateTime?>>? ForFrom { get; set; }
    [Parameter] public Expression<Func<DateTime?>>? ForTo { get; set; }
    [Parameter] public Expression<Func<DateRangeValue>>? ForRange { get; set; }

    private enum RangeField
    {
        From,
        To
    }

    public readonly record struct DateRangeValue(DateTime? From, DateTime? To);

    private string? MinDateString => Min?.ToString("yyyy-MM-dd");
    private string? MaxDateString => Max?.ToString("yyyy-MM-dd");

    private DateTime? BoundFrom
    {
        get => From;
        set => UpdateRange(value, To, RangeField.From);
    }

    private DateTime? BoundTo
    {
        get => To;
        set => UpdateRange(From, value, RangeField.To);
    }

    private void UpdateRange(DateTime? newFrom, DateTime? newTo, RangeField changedField)
    {
        var (normalizedFrom, normalizedTo) = NormalizeRange(newFrom, newTo, changedField);
        var fromChanged = normalizedFrom != From;
        var toChanged = normalizedTo != To;

        if (!fromChanged && !toChanged)
        {
            return;
        }

        From = normalizedFrom;
        To = normalizedTo;

        if (fromChanged)
        {
            _ = FromChanged.InvokeAsync(From);
        }

        if (toChanged)
        {
            _ = ToChanged.InvokeAsync(To);
        }

        if (RangeChanged.HasDelegate)
        {
            _ = RangeChanged.InvokeAsync(new DateRangeValue(From, To));
        }
    }

    private (DateTime?, DateTime?) NormalizeRange(DateTime? from, DateTime? to, RangeField changedField)
    {
        var minimumSpan = Math.Max(1, MinimumSpanDays);

        for (var attempt = 0; attempt < 2; attempt++)
        {
            from = ClampToBounds(from);
            to = ClampToBounds(to);

            if (!ValidateRange || !from.HasValue || !to.HasValue)
            {
                break;
            }

            if (from > to)
            {
                if (changedField == RangeField.From)
                {
                    to = from;
                }
                else
                {
                    from = to;
                }
            }

            if (minimumSpan > 1)
            {
                var inclusiveDays = (to.Value - from.Value).TotalDays + 1;
                if (inclusiveDays < minimumSpan)
                {
                    var offset = minimumSpan - 1;
                    if (changedField == RangeField.From)
                    {
                        to = from.Value.AddDays(offset);
                    }
                    else
                    {
                        from = to.Value.AddDays(-offset);
                    }
                }
            }
        }

        return (from, to);
    }

    private DateTime? ClampToBounds(DateTime? value)
    {
        if (!value.HasValue)
        {
            return null;
        }

        var date = value.Value.Date;

        if (Min.HasValue && date < Min.Value.Date)
        {
            date = Min.Value.Date;
        }

        if (Max.HasValue && date > Max.Value.Date)
        {
            date = Max.Value.Date;
        }

        return date;
    }
}
